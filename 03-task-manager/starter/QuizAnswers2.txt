In this lesson, you created a middleware function called asyncWrapper. Why?


  because every task we are using try and catch to check if the task is completed or not, 
  so there is redundancy in code, to avoid that we are using asyncWrapper.


  Suppose that you want to make sure that both a status code and an error message are sent back to the user when they request the URL for a task that does not exist. Assume that 
  youâ€™ve created a CustomAPIError class and an error handler that references that class. Complete the code:

  const getTask = asyncWrapper(async (req, res, next) => {  
  const { id: taskID } = req.params;  
  const task = await Task.findOne({ _id: taskID });  
  if (!task) {  
    // your code here  
    return next(new CustomAPIError(`Task with ID ${taskID} not found`, 404));  
  }  
  res.status(200).json({ task });  
});  